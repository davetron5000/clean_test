<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>README.rdoc</title>
    <meta http-equiv="Content-Type" content="text/html; charset=ASCII-8BIT" />
    <link rel="stylesheet" href="../css/reset.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../css/github.css" type="text/css" media="screen" />
<script src="../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
<script src="../js/jquery-effect.js" type="text/javascript" charset="utf-8"></script>
<script src="../js/main.js" type="text/javascript" charset="utf-8"></script>
<script src="../js/highlight.pack.js" type="text/javascript" charset="utf-8"></script>

</head>

<body>     
    <div class="banner">
        
        <h1>
            README.rdoc
        </h1>
        <ul class="files">
            <li>README.rdoc</li>
            <li>Last modified: 2012-06-04 11:14:50 -0400</li>
        </ul>
    </div>

    <div id="bodyContent">
        <div id="content">
  
    <div class="description">
      
<h1 id="label-Clean+Tests"><a href="../classes/Clean.html">Clean</a> Tests</h1>
<dl class="rdoc-list note-list"><dt>Author
<dd>
<p>Dave Copeland (<a href="mailto:davetron5000">davetron5000</a> at g mail dot
com)</p>
</dd><dt>Copyright
<dd>
<p>Copyright (c) 2012 by Dave Copeland</p>
</dd><dt>License
<dd>
<p>Distributes under the Apache License, see LICENSE.txt in the source distro</p>
</dd></dl>

<p>Get your Test::Unit test cases readable and fluent, without RSpec, magic,
or crazy meta-programming.</p>

<p>This library is a set of small, simple tools to make your Test::Unit test
cases easy to understand.  This isn't a massive change in how you write
tests, but simply some helpful things will make your tests easier to read.</p>
<ul><li>
<p><a href="http://www.github.com/davetron5000/clean_test">Source</a></p>
</li><li>
<p><a href="http://davetron5000.github.com/clean_test/rdoc">RDoc</a></p>
</li></ul>

<p>The main problems this library solves are:</p>
<ul><li>
<p>Understanding what part of a test method is setup, test, and evaluation</p>
</li><li>
<p>Understanding what elements of a test are relevant to the test, and which
are arbitrary placeholders</p>
</li><li>
<p>Removing the requirement that your tests are method names</p>
</li></ul>

<h2 id="label-Install">Install</h2>

<pre>gem install clean_test</pre>

<p>Or, with bundler:</p>

<pre class="ruby"><span class="ruby-identifier">gem</span> <span class="ruby-string">&quot;clean_test&quot;</span>, :<span class="ruby-identifier">require</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">false</span>
</pre>

<h2 id="label-Overview">Overview</h2>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Circle</span>
  <span class="ruby-identifier">attr_reader</span> :<span class="ruby-identifier">name</span>
  <span class="ruby-identifier">attr_reader</span> :<span class="ruby-identifier">radius</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">initialize</span>(<span class="ruby-identifier">radius</span>,<span class="ruby-identifier">name</span>)
    <span class="ruby-ivar">@radius</span> = <span class="ruby-identifier">radius</span>
    <span class="ruby-ivar">@name</span> = <span class="ruby-identifier">name</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">area</span>
    <span class="ruby-ivar">@radius</span> * <span class="ruby-ivar">@radius</span> * <span class="ruby-value">3.14</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">to_s</span>
    <span class="ruby-node">&quot;circle of radius #{radius}, named #{name}&quot;</span>
  <span class="ruby-keyword">end</span>

<span class="ruby-keyword">end</span>

<span class="ruby-identifier">require</span> <span class="ruby-string">'clean_test/test_case'</span>

<span class="ruby-keyword">class</span> <span class="ruby-constant">CircleTest</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Clean</span><span class="ruby-operator">::</span><span class="ruby-constant">Test</span><span class="ruby-operator">::</span><span class="ruby-constant">TestCase</span>
  <span class="ruby-identifier">test_that</span> <span class="ruby-string">&quot;area is computed correctly&quot;</span> {
    <span class="ruby-constant">Given</span> {
      <span class="ruby-ivar">@circle</span> = <span class="ruby-constant">Circle</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">10</span>,<span class="ruby-identifier">any_string</span>)
    }
    <span class="ruby-constant">When</span> {
      <span class="ruby-ivar">@area</span> = <span class="ruby-ivar">@circle</span>.<span class="ruby-identifier">area</span>
    }
    <span class="ruby-constant">Then</span> {
      <span class="ruby-identifier">assert_equal</span> <span class="ruby-value">314</span>,<span class="ruby-ivar">@area</span>
    }
  }

  <span class="ruby-identifier">test_that</span> <span class="ruby-string">&quot;to_s includes the name&quot;</span> {
    <span class="ruby-constant">Given</span> { 
      <span class="ruby-ivar">@name</span> = <span class="ruby-string">&quot;foo&quot;</span>
      <span class="ruby-ivar">@circle</span> = <span class="ruby-constant">Circle</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">any_int</span>,<span class="ruby-ivar">@name</span>)
    }
    <span class="ruby-constant">When</span> {
      <span class="ruby-ivar">@string</span> = <span class="ruby-ivar">@circle</span>.<span class="ruby-identifier">to_s</span>
    }
    <span class="ruby-constant">Then</span> {
      <span class="ruby-identifier">assert_match</span> <span class="ruby-node">/#{@name}/</span>,<span class="ruby-ivar">@string</span>
    }
  }
<span class="ruby-keyword">end</span>
</pre>

<p>What's going on here?</p>
<ul><li>
<p>We can clearly see which parts of our test are setting things up (stuff
inside <code>Given</code>), which parts are executing the code we're
testing (stuff in <code>When</code>) and which parts are evalulating the
results (stuff in <code>Then</code>)</p>
</li><li>
<p>We can see which values are relevant to the test - only those that are
literals.  In the first test, the <code>name</code> of our circle is not
relevant to the test, so instead of using a dummy value like
<code>&quot;foo&quot;</code>, we use <code>any_string</code>, which makes
it clear that the value <em>does not matter</em>.  Similarly, in the second
test, the radius is irrelevant, so we use <code>any_int</code> to signify
that it doesn't matter.</p>
</li><li>
<p>Our tests are clearly named and described with strings, but we didn't need
to bring in active support.</p>
</li><li>
<p>A side effect of this structure is that we use instance vars to pass data
between Given/When/Then blocks. This means that instance vars "jump out" as
important variables to the test; non-instance vars "fade away" into the
background.</p>
</li></ul>

<p>But, don't fret, this is not an all-or-nothing proposition.  Use whichever
parts you like.  Each feature is in a module that you can include as
needed, or you can do what we're doing here and extend <a
href="../classes/Clean/Test/TestCase.html">Clean::Test::TestCase</a> to get
everything at once.</p>

<h2 id="label-More+Info">More Info</h2>
<ul><li>
<p><a href="../classes/Clean/Test/TestCase.html">Clean::Test::TestCase</a> is
the base class that gives you everything</p>
</li><li>
<p><a
href="../classes/Clean/Test/GivenWhenThen.html">Clean::Test::GivenWhenThen</a>
provides the Given/When/Then construct</p>
</li><li>
<p><a href="../classes/Clean/Test/TestThat.html">Clean::Test::TestThat</a>
provides <code>test_that</code></p>
</li><li>
<p><a href="../classes/Clean/Test/Any.html">Clean::Test::Any</a> provides the
<code>any_string</code> and friends.</p>
</li></ul>

<h2 id="label-Questions+you+might+have">Questions you might have</h2>

<h3 id="label-Why%3F">Why?</h3>

<p>I'm tired of unreadable tests.  Tests should be good, clean code, and it
shoud be easy to see what's being tested.  This is especially important
when there is a lot of setup required to simulate something.</p>

<p>I also don't believe we need to resort to a lot of metaprogramming tricks
just to get our tests in this shape.  RSpec, for example, creates strange
constructs for things that are much more straightforward in plain Ruby.  I
like Test::Unit, and with just a bit of helper methods, we can make nice,
readable tests, using just Ruby.</p>

<h3 id="label-But+the+test+methods+are+longer%21">But the test methods are longer!</h3>

<p>And?  I don't mind a test method that's a bit longer if that makes it easy
to understand.  Certainly, a method like this is short:</p>

<pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-identifier">test_radius</span>
  <span class="ruby-identifier">assert_equal</span> <span class="ruby-value">314</span>,<span class="ruby-constant">Circle</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">10</span>).<span class="ruby-identifier">radius</span>
<span class="ruby-keyword">end</span>
</pre>

<p>But, we rarely get such simple methods <strong>and</strong> this test
method isn't very modifiable; everything is on one line and it doesn't
encourage re-use.  We can do better.</p>

<h3 id="label-What+about+mocks%3F">What about mocks?</h3>

<p>Mocks create an interesting issue, because the "assertions" are the mock
expectations you setup before you call the method under test.  This means
that the "then" side of things is out of order.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">CircleTest</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Test</span><span class="ruby-operator">::</span><span class="ruby-constant">Unit</span><span class="ruby-operator">::</span><span class="ruby-constant">Given</span><span class="ruby-operator">::</span><span class="ruby-constant">TestCase</span>
  <span class="ruby-identifier">test_that</span> <span class="ruby-string">&quot;our external diameter service is being used&quot;</span> <span class="ruby-keyword">do</span>
    <span class="ruby-constant">Given</span> {
      <span class="ruby-ivar">@diameter_service</span> = <span class="ruby-identifier">mock</span>()
      <span class="ruby-ivar">@diameter_service</span>.<span class="ruby-identifier">expects</span>(:<span class="ruby-identifier">get_diameter</span>).<span class="ruby-identifier">with</span>(<span class="ruby-value">10</span>).<span class="ruby-identifier">returns</span>(<span class="ruby-value">400</span>)
      <span class="ruby-ivar">@circle</span> = <span class="ruby-constant">Circle</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">10</span>,<span class="ruby-ivar">@diameter_service</span>)
    }
    <span class="ruby-constant">When</span>  {
      <span class="ruby-ivar">@diameter</span> = <span class="ruby-ivar">@circle</span>.<span class="ruby-identifier">diameter</span>
    }
    <span class="ruby-constant">Then</span> {
      <span class="ruby-regexp">//</span> <span class="ruby-identifier">assume</span> <span class="ruby-identifier">mocks</span> <span class="ruby-identifier">were</span> <span class="ruby-identifier">called</span>
    }
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>This is somewhat confusing.  We could solve it using two blocks provided by
this library, <code>the_test_runs</code>, and
<code>mocks_shouldve_been_called</code>, like so:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">CircleTest</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Test</span><span class="ruby-operator">::</span><span class="ruby-constant">Unit</span><span class="ruby-operator">::</span><span class="ruby-constant">Given</span><span class="ruby-operator">::</span><span class="ruby-constant">TestCase</span>
  <span class="ruby-identifier">test_that</span> <span class="ruby-string">&quot;our external diameter service is being used&quot;</span> <span class="ruby-keyword">do</span>
    <span class="ruby-constant">Given</span> {
      <span class="ruby-ivar">@diameter_service</span> = <span class="ruby-identifier">mock</span>()
    }
    <span class="ruby-constant">When</span> <span class="ruby-identifier">the_test_runs</span>
    <span class="ruby-constant">Then</span> {
      <span class="ruby-ivar">@diameter_service</span>.<span class="ruby-identifier">expects</span>(:<span class="ruby-identifier">get_diameter</span>).<span class="ruby-identifier">with</span>(<span class="ruby-value">10</span>).<span class="ruby-identifier">returns</span>(<span class="ruby-value">400</span>)
    }
    <span class="ruby-constant">Given</span> {
      <span class="ruby-ivar">@circle</span> = <span class="ruby-constant">Circle</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">10</span>,<span class="ruby-ivar">@diameter_service</span>)
    }
    <span class="ruby-constant">When</span>  {
      <span class="ruby-ivar">@diameter</span> = <span class="ruby-ivar">@circle</span>.<span class="ruby-identifier">diameter</span>
    }
    <span class="ruby-constant">Then</span> <span class="ruby-identifier">mocks_shouldve_been_called</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Although both <code>the_test_runs</code> and
<code>mocks_shouldve_been_called</code> are no-ops, they allow our tests to
be readable and make clear what the assertions are that we are making.</p>

<p>Yes, this makes our test a bit longer, but it's <strong>much</strong> more
clear.</p>

<h3 id="label-What+about+block-based+assertions%2C+like+assert_raises">What about block-based assertions, like <code>assert_raises</code></h3>

<p>Again, things are a bit out of order in a class test case, but you can
clean this up without this library or any craziness, by just using Ruby:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">CircleTest</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Clean</span><span class="ruby-operator">::</span><span class="ruby-constant">Test</span><span class="ruby-operator">::</span><span class="ruby-constant">TestCase</span>

  <span class="ruby-identifier">test_that</span> <span class="ruby-string">&quot;there is no diameter method&quot;</span> <span class="ruby-keyword">do</span>
    <span class="ruby-constant">Given</span> {
      <span class="ruby-ivar">@circle</span> = <span class="ruby-constant">Circle</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">10</span>)
    }
    <span class="ruby-constant">When</span> {
      <span class="ruby-ivar">@code</span> = <span class="ruby-identifier">lambda</span> { <span class="ruby-ivar">@circle</span>.<span class="ruby-identifier">diameter</span> }
    }
    <span class="ruby-constant">Then</span> {
      <span class="ruby-identifier">assert_raises</span>(<span class="ruby-constant">NoMethodError</span>,&amp;<span class="ruby-ivar">@code</span>)
    }
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<h3 id="label-My+tests+require+a+lot+of+setup%2C+so+I+use+contexts+in+shoulda%2FRSpec.++What+say+you%3F">My tests require a lot of setup, so I use contexts in shoulda/RSpec.  What say you?</h3>

<p>Duplicated setup can be tricky.  A problem with heavily nested contexts in
Shoulda or RSpec is that it can be hard to piece together what all the
"Givens" of a particular test actually are.  As a reaction to this, a lot
of developers tend to just duplicate setup code, so that each test "stands
on its own".  This makes adding features or changing things difficult,
because it's not clear what duplicated code is the same by happenstance, or
the same because it's <strong>supposed</strong> to be the same.</p>

<p>To deal with this, we simply use Ruby and <em>method extraction</em>. 
Let's say we have a <code>Salutation</code> class that takes a
<code>Person</code> and a <code>Language</code> in its constructor, and
then provides methods to "greet" that person</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Salutation</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">initialize</span>(<span class="ruby-identifier">person</span>,<span class="ruby-identifier">language</span>)
    <span class="ruby-identifier">raise</span> <span class="ruby-string">&quot;person required&quot;</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">person</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-string">&quot;language required&quot;</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">language</span>.<span class="ruby-identifier">nil?</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># ... methods</span>
<span class="ruby-keyword">end</span>
</pre>

<p>To test this class, we always need a non-nil person and language.  We might
end up with code like this:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">SalutationTest</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">Clean</span><span class="ruby-operator">::</span><span class="ruby-constant">Test</span><span class="ruby-operator">::</span><span class="ruby-constant">TestCase</span>
  <span class="ruby-identifier">test_that</span> <span class="ruby-string">&quot;greeting works&quot;</span> <span class="ruby-keyword">do</span>
    <span class="ruby-constant">Given</span> {
      <span class="ruby-identifier">person</span> = <span class="ruby-constant">Person</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;David&quot;</span>,<span class="ruby-string">&quot;Copeland&quot;</span>,:<span class="ruby-identifier">male</span>)
      <span class="ruby-identifier">language</span> = <span class="ruby-constant">Language</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;English&quot;</span>,<span class="ruby-string">&quot;en&quot;</span>)
      <span class="ruby-ivar">@salutation</span> = <span class="ruby-constant">Salutation</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">person</span>,<span class="ruby-identifier">language</span>)
    }
    <span class="ruby-constant">When</span> { 
      <span class="ruby-ivar">@greeting</span> = <span class="ruby-ivar">@salutation</span>.<span class="ruby-identifier">greeting</span>
    }
    <span class="ruby-constant">Then</span> {
      <span class="ruby-identifier">assert_equal</span> <span class="ruby-string">&quot;Hello, David!&quot;</span>,<span class="ruby-ivar">@salutation</span>.<span class="ruby-identifier">greeting</span>
    }
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">test_that</span> <span class="ruby-string">&quot;greeting works for no first name&quot;</span> <span class="ruby-keyword">do</span>
    <span class="ruby-constant">Given</span> {
      <span class="ruby-identifier">person</span> = <span class="ruby-constant">Person</span>.<span class="ruby-identifier">new</span>(<span class="ruby-keyword">nil</span>,<span class="ruby-string">&quot;Copeland&quot;</span>,:<span class="ruby-identifier">male</span>)
      <span class="ruby-identifier">language</span> = <span class="ruby-constant">Language</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;English&quot;</span>,<span class="ruby-string">&quot;en&quot;</span>)
      <span class="ruby-ivar">@salutation</span> = <span class="ruby-constant">Salutation</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">person</span>,<span class="ruby-identifier">language</span>)
    }
    <span class="ruby-constant">When</span> { 
      <span class="ruby-ivar">@greeting</span> = <span class="ruby-ivar">@salutation</span>.<span class="ruby-identifier">greeting</span>
    }
    <span class="ruby-constant">Then</span> {
      <span class="ruby-identifier">assert_equal</span> <span class="ruby-string">&quot;Hello, Mr. Copeland!&quot;</span>,<span class="ruby-ivar">@salutation</span>.<span class="ruby-identifier">greeting</span>
    }
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>In both cases, the language is the same, and the person is slightly
different.  Method extraction:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">SalutationTest</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">Clean</span><span class="ruby-operator">::</span><span class="ruby-constant">Test</span><span class="ruby-operator">::</span><span class="ruby-constant">TestCase</span>
  <span class="ruby-identifier">test_that</span> <span class="ruby-string">&quot;greeting works&quot;</span> <span class="ruby-keyword">do</span>
    <span class="ruby-constant">Given</span> {
      <span class="ruby-ivar">@salutation</span> = <span class="ruby-constant">Salutation</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">male_with_first_name</span>(<span class="ruby-string">&quot;David&quot;</span>),<span class="ruby-identifier">english</span>)
    }
    <span class="ruby-constant">When</span> { 
      <span class="ruby-ivar">@greeting</span> = <span class="ruby-ivar">@salutation</span>.<span class="ruby-identifier">greeting</span>
    }
    <span class="ruby-constant">Then</span> {
      <span class="ruby-identifier">assert_equal</span> <span class="ruby-string">&quot;Hello, David!&quot;</span>,<span class="ruby-ivar">@salutation</span>.<span class="ruby-identifier">greeting</span>
    }
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">test_that</span> <span class="ruby-string">&quot;greeting works for no first name&quot;</span> <span class="ruby-keyword">do</span>
    <span class="ruby-constant">Given</span> {
      <span class="ruby-ivar">@salutation</span> = <span class="ruby-constant">Salutation</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">male_with_no_first_name</span>(<span class="ruby-string">&quot;Copeland&quot;</span>),<span class="ruby-identifier">english</span>)
    }
    <span class="ruby-constant">When</span> { 
      <span class="ruby-ivar">@greeting</span> = <span class="ruby-ivar">@salutation</span>.<span class="ruby-identifier">greeting</span>
    }
    <span class="ruby-constant">Then</span> {
      <span class="ruby-identifier">assert_equal</span> <span class="ruby-string">&quot;Hello, Mr. Copeland!&quot;</span>,<span class="ruby-ivar">@salutation</span>.<span class="ruby-identifier">greeting</span>
    }
  <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">male_with_first_name</span>(<span class="ruby-identifier">first_name</span>)
    <span class="ruby-constant">Person</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">first_name</span>,<span class="ruby-identifier">any_string</span>,:<span class="ruby-identifier">male</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">male_with_no_first_name</span>(<span class="ruby-identifier">last_name</span>)
    <span class="ruby-constant">Person</span>.<span class="ruby-identifier">new</span>(<span class="ruby-keyword">nil</span>,<span class="ruby-identifier">last_name</span>,:<span class="ruby-identifier">male</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">english</span>; <span class="ruby-constant">Language</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;English&quot;</span>,<span class="ruby-string">&quot;en&quot;</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<h3 id="label-What+did+that+have+to+do+with+this+gem%3F">What did that have to do with this gem?</h3>

<p>Nothing.  That's the point.  You have the power already.  That being said,
<code>Given</code> and friends can take a symbol representing the name of a
method to call, in lieu of a block:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">SalutationTest</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">Clean</span><span class="ruby-operator">::</span><span class="ruby-constant">Test</span><span class="ruby-operator">::</span><span class="ruby-constant">TestCase</span>
  <span class="ruby-identifier">test_that</span> <span class="ruby-string">&quot;greeting works&quot;</span> <span class="ruby-keyword">do</span>
    <span class="ruby-constant">Given</span> :<span class="ruby-identifier">english_salutation_for</span>,<span class="ruby-identifier">male_with_first_name</span>(<span class="ruby-string">&quot;David&quot;</span>)
    <span class="ruby-constant">When</span> { 
      <span class="ruby-ivar">@greeting</span> = <span class="ruby-ivar">@salutation</span>.<span class="ruby-identifier">greeting</span>
    }
    <span class="ruby-constant">Then</span> {
      <span class="ruby-identifier">assert_equal</span> <span class="ruby-string">&quot;Hello, David!&quot;</span>,<span class="ruby-ivar">@salutation</span>.<span class="ruby-identifier">greeting</span>
    }
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">test_that</span> <span class="ruby-string">&quot;greeting works for no first name&quot;</span> <span class="ruby-keyword">do</span>
    <span class="ruby-constant">Given</span> :<span class="ruby-identifier">english_salutation_for</span>,<span class="ruby-identifier">male_with_no_first_name</span>(<span class="ruby-string">&quot;Copeland&quot;</span>)
    <span class="ruby-constant">When</span> { 
      <span class="ruby-ivar">@greeting</span> = <span class="ruby-ivar">@salutation</span>.<span class="ruby-identifier">greeting</span>
    }
    <span class="ruby-constant">Then</span> {
      <span class="ruby-identifier">assert_equal</span> <span class="ruby-string">&quot;Hello, Mr. Copeland!&quot;</span>,<span class="ruby-ivar">@salutation</span>.<span class="ruby-identifier">greeting</span>
    }
  <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">male_with_first_name</span>(<span class="ruby-identifier">first_name</span>)
    <span class="ruby-constant">Person</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">first_name</span>,<span class="ruby-identifier">any_string</span>,:<span class="ruby-identifier">male</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">male_with_no_first_name</span>(<span class="ruby-identifier">last_name</span>)
    <span class="ruby-constant">Person</span>.<span class="ruby-identifier">new</span>(<span class="ruby-keyword">nil</span>,<span class="ruby-identifier">last_name</span>,:<span class="ruby-identifier">male</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">english_salutation_for</span>(<span class="ruby-identifier">person</span>)
    <span class="ruby-ivar">@salutation</span> = <span class="ruby-constant">Salutation</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">person</span>,<span class="ruby-constant">Language</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;English&quot;</span>,<span class="ruby-string">&quot;en&quot;</span>))
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<h3 id="label-Why+Any+instead+of+Faker%3F">Why Any instead of Faker?</h3>

<p>Faker is used by Any under the covers, but Faker has two problems:</p>
<ul><li>
<p>We aren't <em>faking</em> values, we're using <em>arbitrary</em> values. 
There's a difference semantically, even if the mechanics are the same</p>
</li><li>
<p>Faker requires too much typing to get arbitrary values.  I'd rather type
<code>any_string</code> than <code>Faker::Lorem.words(1).join(' ')</code></p>
</li></ul>

<h3 id="label-What+about+Factory+Girl%3F">What about Factory Girl?</h3>

<p>Again, FactoryGirl goes through metaprogramming hoops to do something we
can already do in Ruby: call methods.  Factory Girl also places factories
in global scope, making tests more brittle.  You either have a ton of tests
depending on the same factory or you have test-specific factories, all in
global scope.  It's just simpler and more maintainable to use methods and
modules for this.  To re-use "factories" produced by simple methods, just
put them in a module.</p>

<p>Further, the <code>Any</code> module is extensible, in that you can do
stuff like <code>any Person</code>, but you can, and should, just use
methods.  Any helps out with primitives that we tend to use a lot: numbers
and strings.  It's just simpler and, with less moving parts, more
predictable.  This means you spend more time on your tests than on your
test infrastructure.</p>

<h3 id="label-Any+uses+random+numbers+and+strings.++Tests+aren%27t+repeatable%21">Any uses random numbers and strings.  Tests aren't repeatable!</h3>

<p>You can make them repeatable by explicitly setting the random seed to a
literal value.  Also, including Any will record the random seed used and
output it.  You can then set <code>RANDOM_SEED</code> in the environment to
re-run he tests using that seed.</p>

<p>Keep in mind that if <em>any</em> value will work, random values shouldn't
be a problem.</p>

<h3 id="label-What+about+not+using+the+base+class%3F">What about not using the base class?</h3>

<p>To use Any on its own:</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">'clean_test/any'</span>

<span class="ruby-keyword">class</span> <span class="ruby-constant">MyTest</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Test</span><span class="ruby-operator">::</span><span class="ruby-constant">Unit</span><span class="ruby-operator">::</span><span class="ruby-constant">TestCase</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">Clean</span><span class="ruby-operator">::</span><span class="ruby-constant">Test</span><span class="ruby-operator">::</span><span class="ruby-constant">Any</span>
<span class="ruby-keyword">end</span>
</pre>

<p>To use GivenWhenThen on its own:</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">'clean_test/given_when_then'</span>

<span class="ruby-keyword">class</span> <span class="ruby-constant">MyTest</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Test</span><span class="ruby-operator">::</span><span class="ruby-constant">Unit</span><span class="ruby-operator">::</span><span class="ruby-constant">TestCase</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">Clean</span><span class="ruby-operator">::</span><span class="ruby-constant">Test</span><span class="ruby-operator">::</span><span class="ruby-constant">GivenWhenThen</span>
<span class="ruby-keyword">end</span>
</pre>

<p>To use TestThat on its own:</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">'clean_test/test_that'</span>

<span class="ruby-keyword">class</span> <span class="ruby-constant">MyTest</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Test</span><span class="ruby-operator">::</span><span class="ruby-constant">Unit</span><span class="ruby-operator">::</span><span class="ruby-constant">TestCase</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">Clean</span><span class="ruby-operator">::</span><span class="ruby-constant">Test</span><span class="ruby-operator">::</span><span class="ruby-constant">TestThat</span>
<span class="ruby-keyword">end</span>
</pre>

    </div>
  


  


  
  


  


  

  



  

    

    

    


    


    <!-- Methods -->
              </div>
    </div>
  </body>
</html>