{"name":"Clean test","body":"# Clean Tests\r\n\r\n* Author - Dave Copeland (mailto:davetron5000 at g mail dot com)\r\n* Copyright - Copyright (c) 2012 by Dave Copeland\r\n* License - Distributes under the Apache License, see LICENSE.txt in the source distro\r\n\r\nGet your Test::Unit test cases readable and fluent, without RSpec, magic, or crazy meta-programming.\r\n\r\nThis library is a set of small, simple tools to make your Test::Unit test cases easy to understand.  This isn't a massive change in how you write tests, but simply some helpful things will make your tests easier to read.\r\n\r\n* [Source](http://www.github.com/davetron5000/clean_test)\r\n* [RDoc](http://davetron5000.github.com/clean_test/rdoc)\r\n\r\nThe main problems this library solves are:\r\n\r\n* Understanding what part of a test method is setup, test, and evaluation\r\n* Understanding what elements of a test are relevant to the test, and which are arbitrary placeholders\r\n* Removing the requirement that your tests are method names\r\n\r\n## Install\r\n\r\n    gem install clean_test\r\n\r\nOr, with bundler:\r\n\r\n    gem \"clean_test\", :require => false\r\n\r\n## Overview\r\n\r\n```ruby\r\nclass Circle\r\n  attr_reader :name\r\n  attr_reader :radius\r\n\r\n  def initialize(radius,name)\r\n    @radius = radius\r\n    @name = name\r\n  end\r\n\r\n  def area\r\n    @radius * @radius * 3.14\r\n  end\r\n\r\n  def to_s\r\n    \"circle of radius #{radius}, named #{name}\"\r\n  end\r\n\r\nend\r\n\r\nrequire 'clean_test/test_case'\r\n\r\nclass CircleTest < Clean::Test::TestCase\r\n  test_that \"area is computed correctly\" {\r\n    Given {\r\n      @circle = Circle.new(10,any_string)\r\n    }\r\n    When {\r\n      @area = @circle.area\r\n    }\r\n    Then {\r\n      assert_equal 314,@area\r\n    }\r\n  }\r\n\r\n  test_that \"to_s includes the name\" {\r\n    Given { \r\n      @name = \"foo\"\r\n      @circle = Circle.new(any_int,@name)\r\n    }\r\n    When {\r\n      @string = @circle.to_s\r\n    }\r\n    Then {\r\n      assert_match /#{@name}/,@string\r\n    }\r\n  }\r\nend\r\n```\r\n\r\nWhat's going on here?\r\n\r\n* We can clearly see which parts of our test are setting things up (stuff inside `Given`), which parts are executing the code we're testing (stuff in `When`) and which parts are evalulating the results (stuff in `Then`)\r\n* We can see which values are relevant to the test - only those that are literals.  In the first test, the `name` of our circle is not relevant to the test, so instead of using a dummy value like <tt>\"foo\"</tt>, we use `any_string`, which makes it clear that the value <i>does not matter</i>.  Similarly, in the second test, the radius is irrelevant, so we use `any_int` to signify that it doesn't matter.\r\n* Our tests are clearly named and described with strings, but we didn't need to bring in active support.\r\n* A side effect of this structure is that we use instance vars to pass data between Given/When/Then blocks. This means that instance vars \"jump out\" as important variables to the test; non-instance vars \"fade away\" into the background.\r\n\r\nBut, don't fret, this is not an all-or-nothing proposition.  Use whichever parts you like.  Each feature is in a module that you can include as needed, or you can do what we're doing here and extend Clean::Test::TestCase to get everything at once.\r\n\r\n## More Info\r\n\r\n* Clean::Test::TestCase is the base class that gives you everything\r\n* Clean::Test::GivenWhenThen provides the Given/When/Then construct\r\n* Clean::Test::TestThat provides `test_that`\r\n* Clean::Test::Any provides the `any_string` and friends.\r\n\r\n## Questions you might have\r\n\r\n### Why?\r\n\r\nI'm tired of unreadable tests.  Tests should be good, clean code, and it shoud be easy to see what's being tested.  This is especially important when there is a lot of setup required to simulate something.\r\n\r\nI also don't believe we need to resort to a lot of metaprogramming tricks just to get our tests in this shape.  RSpec, for example, creates strange constructs for things that are much more straightforward in plain Ruby.  I like Test::Unit, and with just a bit of helper methods, we can make nice, readable tests, using just Ruby.\r\n\r\n### But the test methods are longer!\r\n\r\nAnd?  I don't mind a test method that's a bit longer if that makes it easy to understand.  Certainly, a method like this is short:\r\n\r\n```ruby\r\ndef test_radius\r\n  assert_equal 314,Circle.new(10).radius\r\nend\r\n```\r\n\r\nBut, we rarely get such simple methods *and* this test method isn't very modifiable; everything is on one line and it doesn't encourage re-use.  We can do better.\r\n\r\n### What about mocks?\r\n\r\nMocks create an interesting issue, because the \"assertions\" are the mock expectations you setup before you call the method under test.  This means that the \"then\" side of things is out of order.\r\n\r\n```ruby\r\nclass CircleTest < Test::Unit::Given::TestCase\r\n  test_that \"our external diameter service is being used\" do\r\n    Given {\r\n      @diameter_service = mock()\r\n      @diameter_service.expects(:get_diameter).with(10).returns(400)\r\n      @circle = Circle.new(10,@diameter_service)\r\n    }\r\n    When  {\r\n      @diameter = @circle.diameter\r\n    }\r\n    Then {\r\n      // assume mocks were called\r\n    }\r\n  end\r\nend\r\n```\r\n\r\nThis is somewhat confusing.  We could solve it using two blocks provided by this library, `the_test_runs`, and `mocks_shouldve_been_called`, like so:\r\n\r\n```ruby\r\nclass CircleTest < Test::Unit::Given::TestCase\r\n  test_that \"our external diameter service is being used\" do\r\n    Given {\r\n      @diameter_service = mock()\r\n    }\r\n    When the_test_runs\r\n    Then {\r\n      @diameter_service.expects(:get_diameter).with(10).returns(400)\r\n    }\r\n    Given {\r\n      @circle = Circle.new(10,@diameter_service)\r\n    }\r\n    When  {\r\n      @diameter = @circle.diameter\r\n    }\r\n    Then mocks_shouldve_been_called\r\n  end\r\nend\r\n```\r\n\r\nAlthough both <tt>the_test_runs</tt> and <tt>mocks_shouldve_been_called</tt> are no-ops,\r\nthey allow our tests to be readable and make clear what the assertions are that we are making.\r\n\r\nYes, this makes our test a bit longer, but it's *much* more clear.\r\n\r\n### What about block-based assertions, like `assert_raises`\r\n\r\nAgain, things are a bit out of order in a class test case, but you can clean this up without this library or any craziness, by just using Ruby:\r\n\r\n```ruby\r\nclass CircleTest < Clean::Test::TestCase\r\n\r\n  test_that \"there is no diameter method\" do\r\n    Given {\r\n      @circle = Circle.new(10)\r\n    }\r\n    When {\r\n      @code = lambda { @circle.diameter }\r\n    }\r\n    Then {\r\n      assert_raises(NoMethodError,&@code)\r\n    }\r\n  end\r\nend\r\n```\r\n\r\n### My tests require a lot of setup, so I use contexts in shoulda/RSpec.  What say you?\r\n\r\nDuplicated setup can be tricky.  A problem with heavily nested contexts in Shoulda or RSpec is that it can be hard to piece together what all the \"Givens\" of a particular test actually are.  As a reaction to this, a lot of developers tend to just duplicate setup code, so that each test \"stands on its own\".  This makes adding features or changing things difficult, because it's not clear what duplicated code is the same by happenstance, or the same because it's *supposed* to be the same.\r\n\r\nTo deal with this, we simply use Ruby and <i>method extraction</i>.  Let's say we have a `Salutation` class that takes a `Person` and a `Language` in its constructor, and then provides methods to \"greet\" that person\r\n\r\n```\r\nclass Salutation\r\n  def initialize(person,language)\r\n    raise \"person required\" if person.nil?\r\n    raise \"language required\" if language.nil?\r\n  end\r\n\r\n  # ... methods\r\nend\r\n```\r\n\r\nTo test this class, we always need a non-nil person and language.  We might end up with code like this:\r\n\r\n```ruby\r\nclass SalutationTest << Clean::Test::TestCase\r\n  test_that \"greeting works\" do\r\n    Given {\r\n      person = Person.new(\"David\",\"Copeland\",:male)\r\n      language = Language.new(\"English\",\"en\")\r\n      @salutation = Salutation.new(person,language)\r\n    }\r\n    When { \r\n      @greeting = @salutation.greeting\r\n    }\r\n    Then {\r\n      assert_equal \"Hello, David!\",@salutation.greeting\r\n    }\r\n  end\r\n\r\n  test_that \"greeting works for no first name\" do\r\n    Given {\r\n      person = Person.new(nil,\"Copeland\",:male)\r\n      language = Language.new(\"English\",\"en\")\r\n      @salutation = Salutation.new(person,language)\r\n    }\r\n    When { \r\n      @greeting = @salutation.greeting\r\n    }\r\n    Then {\r\n      assert_equal \"Hello, Mr. Copeland!\",@salutation.greeting\r\n    }\r\n  end\r\nend\r\n```\r\n\r\nIn both cases, the language is the same, and the person is slightly different.  Method extraction:\r\n\r\n```ruby\r\nclass SalutationTest << Clean::Test::TestCase\r\n  test_that \"greeting works\" do\r\n    Given {\r\n      @salutation = Salutation.new(male_with_first_name(\"David\"),english)\r\n    }\r\n    When { \r\n      @greeting = @salutation.greeting\r\n    }\r\n    Then {\r\n      assert_equal \"Hello, David!\",@salutation.greeting\r\n    }\r\n  end\r\n\r\n  test_that \"greeting works for no first name\" do\r\n    Given {\r\n      @salutation = Salutation.new(male_with_no_first_name(\"Copeland\"),english)\r\n    }\r\n    When { \r\n      @greeting = @salutation.greeting\r\n    }\r\n    Then {\r\n      assert_equal \"Hello, Mr. Copeland!\",@salutation.greeting\r\n    }\r\n  end\r\n\r\nprivate\r\n  def male_with_first_name(first_name)\r\n    Person.new(first_name,any_string,:male)\r\n  end\r\n\r\n  def male_with_no_first_name(last_name)\r\n    Person.new(nil,last_name,:male)\r\n  end\r\n\r\n  def english; Language.new(\"English\",\"en\"); end\r\nend\r\n```\r\n\r\n### What did that have to do with this gem?\r\n\r\nNothing.  That's the point.  You have the power already.  That being said, `Given` and friends can take a symbol representing the name of a method to call, in lieu of a block:\r\n\r\n```ruby\r\nclass SalutationTest << Clean::Test::TestCase\r\n  test_that \"greeting works\" do\r\n    Given :english_salutation_for,male_with_first_name(\"David\")\r\n    When { \r\n      @greeting = @salutation.greeting\r\n    }\r\n    Then {\r\n      assert_equal \"Hello, David!\",@salutation.greeting\r\n    }\r\n  end\r\n\r\n  test_that \"greeting works for no first name\" do\r\n    Given :english_salutation_for,male_with_no_first_name(\"Copeland\")\r\n    When { \r\n      @greeting = @salutation.greeting\r\n    }\r\n    Then {\r\n      assert_equal \"Hello, Mr. Copeland!\",@salutation.greeting\r\n    }\r\n  end\r\n\r\nprivate\r\n  def male_with_first_name(first_name)\r\n    Person.new(first_name,any_string,:male)\r\n  end\r\n\r\n  def male_with_no_first_name(last_name)\r\n    Person.new(nil,last_name,:male)\r\n  end\r\n\r\n  def english_salutation_for(person)\r\n    @salutation = Salutation.new(person,Language.new(\"English\",\"en\"))\r\n  end\r\nend\r\n```\r\n\r\n### Why Any instead of Faker?\r\n\r\nFaker is used by Any under the covers, but Faker has two problems:\r\n\r\n* We aren't _faking_ values, we're using _arbitrary_ values.  There's a difference semantically, even if the mechanics are the same\r\n* Faker requires too much typing to get arbitrary values.  I'd rather type `any_string` than <tt>Faker::Lorem.words(1).join(' ')</tt>\r\n\r\n### What about Factory Girl?\r\n\r\nAgain, FactoryGirl goes through metaprogramming hoops to do something we can already do in Ruby: call methods.  Factory Girl also places factories in global scope, making tests more brittle.  You either have a ton of tests depending on the same factory or you have test-specific factories, all in global scope.  It's just simpler and more maintainable to use methods and modules for this.  To re-use \"factories\" produced by simple methods, just put them in a module.\r\n\r\nFurther, the `Any` module is extensible, in that you can do stuff like <tt>any Person</tt>, but you can, and should, just use methods.  Any helps out with primitives that we tend to use a lot: numbers and strings.  It's just simpler and, with less moving parts, more predictable.  This means you spend more time on your tests than on your test infrastructure.\r\n\r\n### Any uses random numbers and strings.  Tests aren't repeatable!\r\n\r\nYou can make them repeatable by explicitly setting the random seed to a literal value.  Also, including Any will record\r\nthe random seed used and output it.  You can then set `RANDOM_SEED` in the environment to re-run he tests using that seed.\r\n\r\nKeep in mind that if _any_ value will work, random values shouldn't be a problem.\r\n\r\n### What about not using the base class?\r\n\r\nTo use Any on its own:\r\n\r\n```ruby\r\nrequire 'clean_test/any'\r\n\r\nclass MyTest < Test::Unit::TestCase\r\n  include Clean::Test::Any\r\nend\r\n```\r\n\r\nTo use GivenWhenThen on its own:\r\n\r\n```ruby\r\nrequire 'clean_test/given_when_then'\r\n\r\nclass MyTest < Test::Unit::TestCase\r\n  include Clean::Test::GivenWhenThen\r\nend\r\n```\r\n\r\nTo use TestThat on its own:\r\n\r\n```ruby\r\nrequire 'clean_test/test_that'\r\n\r\nclass MyTest < Test::Unit::TestCase\r\n  include Clean::Test::TestThat\r\nend\r\n```\r\n","tagline":"Write clean, understandable tests in Test::Unit","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}